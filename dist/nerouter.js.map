{"version":3,"sources":["webpack://nerouter/webpack/universalModuleDefinition","webpack://nerouter/webpack/bootstrap","webpack://nerouter/./src/finder.js","webpack://nerouter/./src/index.js","webpack://nerouter/./src/matcher.js","webpack://nerouter/./src/route.js","webpack://nerouter/./src/tokenizer.js","webpack://nerouter/./src/util.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;ACnEA;;;AAGA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;;AAEA;;;AAGA;;AAEA;;;AAGA;;AAEA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA,sBAAsB;AACtB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,0CAA0C,SAAS;;AAEnD;AACA;;AAEA;AACA;AACA,oC;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;;;AAGA;;AAEA;;AAEA;;;AAGA;;AAEA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;;AAEA;;;AAGA,kBAAkB;;;;;;;;;;;;;;;ACpHlB;AACA;AACA,C;;;;;;;;;;;;ACFA,OAAO,wBAAwB;AAC/B;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;;AAEA;AACA;AACA;;AAEA;;;AAGA;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA,WAAW,0BAA0B;AACrC;;AAEA,2D;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,4CAA4C,UAAU;;AAEtD;AACA;;AAEA;;AAEA;;AAEA,SAAS,M;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,WAAW,uCAAuC;;AAElD;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;;AAGA;;;;;;;;;;;;;AC/GA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iB;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,CAAC;AACD;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wCAAwC,SAAS;;AAEjD;;AAEA;AACA;AACA,SAAS,OAAO;;AAEhB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;;AAEA;;AAEA;;;AAGA;;AAEA,0CAA0C,SAAS;;AAEnD;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;AC9IA;;AAEA,OAAO,iBAAiB;;;AAGxB;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA,WAAW,yBAAyB;AACpC,0BAA0B,2BAA2B;;AAErD;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4BAA4B;AACxD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,+F;;AAEA;;AAEA;;AAEA;;AAEA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,aAAa;;AAEb;;AAEA;AACA;;AAEA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;;AAEA;AACA;AACA;;AAEA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,KAAK;AACL;AACA;;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;;AAIA;;;;;;;;;;;;;;;;;;;;ACzPA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA,qCAAqC;AACrC;;;AAGA;AACA,oBAAoB;AACpB;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA,C","file":"nerouter.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"nerouter\"] = factory();\n\telse\n\t\troot[\"nerouter\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","// find the route via path\n\n\n/**\n * find 是 context param \n * @param  {Object} route   [description]\n * @param  {String} index   当前下标\n * @param  {Object} context 递归过程中，有一些通用上下文需要传递\n *                  - pathes: 总路径\n *                  - index: 当前路径下标\n *                  - param: 已经设置的参数对象\n * @return {Object}         [description]\n */\nfunction find ( route, index, context ){\n\n    index = index || 0;\n\n\n    let found = findStatic( route, index, context );\n\n    if( found ) return found;\n    \n\n    return findDynamic( route, index, context );\n    \n}\n\n\n/**\n * [findStatic 描述]\n */\nfunction findStatic( route, index, context ){\n\n    const path = context.pathes[index];\n\n    const staticMap = route.staticMap;\n\n    const found = staticMap[ path ];\n\n    if( found ) {\n        const isLast = index === context.length - 1;\n\n        // if absolute match or  the route has end === false option\n        if( isLast  ){ // need registed\n            return found.touched? found: null;\n        }\n\n        let childFound = find(found, index+1, context);\n        if( childFound ) return childFound\n\n        // end means touched\n        if(found.end === false ) return found\n        \n    }\n}\n\n\n/**\n * [findDynamic 描述]\n */\nfunction findDynamic( route, index, context ){\n\n    const path = context.pathes[index];\n    const patterns = route.patterns;\n    const isLast = context.length-1 === index;\n\n    if( !patterns.length ) return null;\n\n    for( let i = 0, len = patterns.length; i < len; i++ ){\n\n        let pattern = patterns[i];\n        if(!pattern) continue;\n\n        let regexp = pattern.regexp;\n        // use test for better performance\n        let ret = regexp.exec(path); \n\n\n        if(ret){\n            // 后面有没有找到\n\n            let nextRoute = pattern.route;\n\n            if( isLast ){\n                if(!nextRoute.touched) return ;\n                buildParam( ret, pattern.slots , pattern.names, context.param ) \n                \n                return  nextRoute;\n            }\n\n            let nextFound = find( nextRoute, index + 1, context );\n\n\n            if(nextFound || nextRoute.end === false ) {\n                buildParam( ret, pattern.slots , pattern.names, context.param ) \n                return nextFound? nextFound : nextRoute;\n            }\n\n\n        }\n\n    }\n\n}\n\n\nfunction buildParam( execRet, slots, names, param){\n\n    for( let i = 0, len = names.length ; i < len; i++ ){\n        // @TODO warning same param\n        const name =  names[i];\n        param[name] = execRet[slots[i]]\n    }\n\n}\n\n\nmodule.exports = { find }\n\n\n","\nmodule.exports = {\n    Matcher: require('./matcher.js')\n}","\nconst { extend, cachedHashMap } = require('./util');\nconst Tokenizer = require('./tokenizer');\nconst rutil = require('./route');\nconst finder = require('./finder');\nconst rClean = /^\\/+|\\/+$/;\nconst rStatic = /[:(]/\n\n\nfunction Matcher( option ){\n\n    option = option || {};\n\n    this.dynamicRoute = rutil.create();\n    this.staticRoute = {}\n    this.delimiter = option.delimiter || '/'\n\n}\n\n\nconst mo = Matcher.prototype;\n\n\nmo.add = function( path, option ){\n\n    option = option || {}\n    const delimiter = this.delimiter;\n    const end =  option.end;\n    const strict = option.strict;\n\n    const {dynamicRoute, staticRoute} = this;\n    //@TODO when option.end === true or option.strict === true ?? \n\n    let isStatic = end !== false && !(rStatic.test(path)) ; \n\n    if(isStatic){\n        if(staticRoute[path]) throw error('path ' + path + ' is already registed')\n        staticRoute[ path ] = { marker: option.marker }\n        return ;\n    }\n\n    let tokenStream = new Tokenizer( path , option ).tokenize();\n\n    // 当前rutil引用\n    let curRoute = this.dynamicRoute, \n        context = {\n            unnamedCapture: 0\n        };\n\n    for(let i = 0, len = tokenStream.length; i < len ; i++){\n\n        let tokenObj = tokenStream[i]\n        let tokens = tokenObj.tokens;\n\n        if( !tokenObj.pattern ){\n\n            curRoute = rutil.addRoute( curRoute, tokens.join() );\n\n        }else { \n\n            curRoute = rutil.addPattern( curRoute, tokenObj, context );\n        }\n    }\n    if(curRoute.touched) throw error('path ' + path + ' is already registed')\n    curRoute.touched = true;\n    curRoute.marker = option.marker;\n    curRoute.end = end === false? false: true;\n    curRoute.strict = strict === false? false: true;\n    return curRoute;\n} \n\n\nmo.find = function(path, option){\n\n    let param = {}\n    let route =  this._find(path, param, option);\n\n    if(route ){\n        return {\n            marker: route.marker,\n            param \n        }\n    }else{\n        return null\n    }\n}\n\nmo._find = function( path, param ,option ){\n\n    option = option || {}\n    if(typeof path !== 'string' || !path) throw error('path invalid');\n\n    const { dynamicRoute, staticRoute, delimiter } = this;\n\n    path = path.trim();\n\n    if( staticRoute[path] ) return staticRoute[path]\n\n    const lastDelimiter = path.charAt(path.length-1) === delimiter \n    const pathes = path.replace( rClean, '').split(delimiter);\n\n    return finder.find(dynamicRoute, 0, {\n        length: pathes.length,\n        pathes,\n        param: param,\n        lastDelimiter\n    })\n\n}\n\n\nmodule.exports = Matcher\n\n","/**\n\n{\n    patterns: [ \n        {\n            key: regStr,\n            regexp: /regexp/, // 以patter作为分解. 不重复探测一样的pattern\n            slots: [0, 2], param slot\n            matches: {\n                ':id': {\n                    names: ['id'],\n                    route: Route\n                }    \n            }\n        }\n    ],\n    marker: {},\n    last: false,\n    option: {\n        end: true,\n        strict: true,\n        delimiter: true,\n        // sensitive: true  暂时不支持，否则需要保存两份\n    },\n    route: {\n        blog: Route\n    }\n}\n\n * \n */\n\n\nconst {\n    cachedHashMap,\n    escapeRegexp\n} = require('./util');\n// save the regexp to . to avoid memory leak\nconst regExpCache = cachedHashMap(1000);\n\n\nfunction create() {\n    return {\n        patterns: [],\n        staticMap: {}\n    }\n}\n\n\nfunction addPattern(route, tokenObj, context) {\n\n\n    let captureIndex = 1,\n        tokens = tokenObj.tokens,\n        unnamedCapture = context.unnamedCapture || 0,\n        ret = '',\n        names = [], slots=[],\n        anonyCapture = 0,\n        raw = tokenObj.raw;\n\n    for (let j = 0, len = tokens.length; j < len; j++) {\n\n        let token = tokens[j];\n\n        if (typeof token === 'string') {\n            ret += escapeRegexp(token);\n        } else { // @TODO  other type\n\n            slots.push(captureIndex);\n            names.push(token.name? token.name:  unnamedCapture + anonyCapture++)\n\n            captureIndex += token.retain;\n            ret += '(' + token.value + ')' + (token.optional? '?':'')\n        }\n    }\n    let path = '^' + ret + '$';\n\n    context.unnamedCapture += anonyCapture;\n\n    const reg = regExpCache.get( path ) || regExpCache.set( path, new RegExp(path) );\n\n    const patterns = route.patterns;\n\n    let pattern = findPattern( patterns, path );\n\n    if( pattern ) {\n        if( !sameArray(pattern.names, names) ) {\n            throw Error('named Capture conflict ' + raw + ' -> ' + pattern.raw )\n        }\n        return pattern.route;\n    }\n\n    pattern = {\n        key: path,\n        regexp: reg,\n        raw,\n        slots,\n        names,\n        route: create()\n    }\n\n    patterns.push( pattern );\n\n    return pattern.route\n}\n\nfunction sameArray(arr1, arr2){\n    if(arr2.length !== arr1.length) return false;\n\n    for(let i=0, len = arr1.length; i < len; i++){\n        if(arr1[i] !== arr2[i]) return false;\n    }\n    return true\n}\n\n\n\n\n/**\n * 增加静态Route\n */\nfunction addRoute(route, name) {\n\n    return route.staticMap[name] ||  (route.staticMap[name] = create())\n\n}\n\n\nfunction findPattern(patterns, path) {\n\n    for( let i = 0,len = patterns.length ; i < len; i++ ) {\n\n        if(patterns[i].key === path) return patterns[i]\n\n    }\n}\n\n\nmodule.exports = {\n    create,\n    addRoute,\n    addPattern\n}","// build the route via pattern\n\nconst { extend, error  } = require('./util');\n\n\n// path \n\nconst DEFAULT_CAPTURE_PATTERN = '\\\\w+'\nconst ignoredRef = /\\((\\?\\!|\\?\\:|\\?\\=)/g;\n\nfunction Tokenizer(input, option) {\n\n    this.index = 0;\n    this.input = input;\n    this.length = input.length;\n    this.delimiter = option.delimiter || '/';\n    this.option = option;\n    this.tokens = [];\n    this.paramMap= {};\n}\n\nconst to = Tokenizer.prototype;\n\n\nto.tokenize = function() {\n    const {length, delimiter, input} = this;\n    const tokenStream = [{pattern: false, tokens: []}];\n\n    let tokenObj = tokenStream[0];\n\n    if(input[0] === delimiter) this.index = 1;\n    let preSlashIndex = this.index;\n\n    // index Or \n    while ( (char = input[this.index]) && this.index < length ) {\n\n\n        switch ( char ) {\n            case ':':\n                tokenObj.tokens.push( this.readNamedCapture() );\n                tokenObj.pattern = true;\n                break;\n            case '(':\n                tokenObj.tokens.push( this.readCapture() );\n                tokenObj.pattern = true;\n                break;\n            case delimiter:\n                if( tokenObj.pattern ){\n                    tokenObj.raw = input.substring( preSlashIndex, this.index )\n                }\n                this.index++;\n                tokenObj = { pattern:false, tokens: [] } ;\n                tokenStream.push(tokenObj);\n                preSlashIndex = this.index;\n\n                break;\n            default:\n                tokenObj.tokens.push(this.readAnyOther());\n\n        }\n    }\n    if( tokenObj.pattern ){\n        tokenObj.raw = input.substring( preSlashIndex, this.index )\n    }\n    return tokenStream;\n}\n\n\n\nto.char = function(offset) {\n    return this.input[this.index + (offset || 0)];\n}\n\nto.readNamedCapture = function() {\n\n    this.index++;\n    const word = this.readWord();\n\n    let capture\n\n    if( this.paramMap[word.value] ) throw error('Conflict param: ' + word.value, 'ParseError'); \n\n    this.paramMap[word.value] = 1;\n\n    if( this.char() === '(' ) {\n\n        capture = this.readCapture();\n\n    }else{\n\n        capture = {\n            value: DEFAULT_CAPTURE_PATTERN,\n            retain: 1\n        }\n        if(this.eat('?')){\n            capture.optional = true;\n        }\n    }\n\n    capture.name = word.value;\n    return capture\n}\n\nto.readCapture = function(){\n\n    let subCaptrueOpen = subCaptrue = 0;\n    this.match('(');\n    let start = this.index;\n    let char, input = this.input;\n\n    while( char = input[ start ] ){\n\n        if( input[ start - 1 ]  !== '\\\\' ){\n\n            if( char === '(' ){\n\n                subCaptrueOpen++ ;\n\n            }else if( char === ')' ){\n\n                if( subCaptrueOpen > 0 ){\n\n                    subCaptrueOpen--;\n                    subCaptrue++;\n\n                }else{\n                    break;\n                }\n\n            }\n        }\n        start++;\n\n    }\n\n    let value = this.input.substring( this.index, start );\n\n    let ignored = 0\n    if(subCaptrue){\n        let ignoredRet = value.match( ignoredRef );\n\n        if(ignoredRet) ignored = ignoredRet.length;\n    }\n\n    let token = {\n        type: 'pattern',\n        retain: subCaptrue - ignored + 1,\n        value\n    }\n\n\n    this.index = start;\n\n    this.match(')');\n\n    if(this.eat('?')){\n        token.optional = true\n    }\n\n    return token;\n\n\n}\n\nto.match = function( char){\n\n   if( !this.eat(char) ) throw error('expect '+ char + ' got ' + this.char(), 'ParseError');\n\n}\n\nto.eat = function(char){\n    if(this.char() === char){\n        this.index++;\n        return char\n    }\n    return false;\n}\n\n\nto.readWord = function(){\n\n    let end = this.index + 1;\n    let input = this.input;\n\n    while( isAlpha( input[end] ) ){\n\n        end++;\n\n    }\n\n    if(end > this.index){\n        let token = {\n            type:'word',\n            value: this.input.substring(this.index, end)\n        }\n        this.index = end;\n\n        return token;\n    }else{\n\n        throw Error('readAlpha failed')\n    }\n\n}\n\nto.readAnyOther = function() {\n    const input = this.input;\n    let end = this.index;\n\n\n    let char = input[end];\n    while (isAnyOther(char) && char !== this.delimiter) {\n\n        if(char === '?' || char === '+' || char === '*'){\n            throw Error('unsupport token ' + char)\n        }\n\n        char = input[++end]\n    }\n\n    if ( end > this.index) {\n\n        let token = this.input.substring(this.index, end);\n        this.index = end;\n        return token;\n\n    } else {\n        throw Error('readAnyOther failed')\n    }\n\n}\n\n\n\n\nfunction isAlpha( c ){\n    return  (c >= 'a' && c <= 'z') ||\n            (c >= 'A' && c <= 'Z') ||\n            (c >= '0' && c <= '9') ||\n            c === '_';\n}\n\n\nfunction isAnyOther(char) {\n    return char && char !== '(' && char !== ':'\n}\n\n\n\nmodule.exports = Tokenizer;\n\n\n\n\n\n\n\n\n","// function extend(o1, o2, override) {\n//     for (var i in o2)\n//         if (override || o1[i] === undefined) {\n//             o1[i] = o2[i];\n//         }\n//     return o1;\n// };\n\n\n// 避免内存泄漏\nfunction cachedHashMap( option ) {\n    option = option || {};\n\n    var keys = [],\n        limit = option.limit || 100,\n        cache = {};\n\n    return {\n        set: function(key, value) {\n            if (keys.length > this.limit) {\n                cache[keys.shift()] = undefined;\n            }\n            //\n            if (cache[key] === undefined) {\n                keys.push(key);\n            }\n            cache[key] = value;\n            return value;\n        },\n        get: function(key) {\n            return cache[key];\n        },\n        limit: limit\n    };\n}\n\nfunction escapeRegexp( str ) {\n    return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, '\\\\$1')\n}\n\n\nfunction error( message, name ){\n    let errorObj = {message}\n    if(name) errorObj.name = name\n    return errorObj;\n}\n\n\n\nmodule.exports = {\n    // extend,\n    cachedHashMap,\n    escapeRegexp,\n    error\n}"],"sourceRoot":""}